module Ensembl
  
  module Core
      
    class Exon < DBConnection
      
      def self.find_by_stable_id(stable_id)
				return Ensembl::Core::ExonStableId.find_by_stable_id(stable_id).exon
      end
      
      def stable_id
	 			return self.exon_stable_id.stable_id
      end
            
    end
   
    class Xref < DBConnection
      
      def genes        
        answer = []        
        self.object_xrefs.each do |ox|
          answer << Ensembl::Core::Gene.find(ox.ensembl_id) if ox.ensembl_object_type == "Gene"
        end        
        return answer        
      end
      
    end
   	
    class Gene < DBConnection
      
      
      def structure_to_svg(x=10,y=150)

      	coordinates = []
      	introns = self.fetch_noncoding
      	
      	introns.each do |nc|
      		coordinates << nc.start
      		coordinates << nc.stop
      	end
      	
      	coordinates.sort!
      	
      	graph_width = 700
      	gene_length = self.stop-self.start.to_i
      	
      	graph = SVGWriter::Graph.new(graph_width+50)
      	
      	graph.add_path({:x => x, :y => y + 10},graph_width-20)

      	previous = self.start
      	
      	#iterate over non-coding regions and determine coordinates for coding regions
      	until coordinates.empty?      	
      		this_start = coordinates.shift.to_i
      		this_stop = coordinates.shift.to_i     		
      		this_width = (graph_width.to_f/gene_length.to_f)*(this_start-previous)
      		this_x = (graph_width.to_f/gene_length.to_f)*(previous-self.start)+x
      		this_y = y		
      		graph.add_rectangle({:x => this_x, :y => this_y},this_width) 		
      		if coordinates.empty? # coordinates for the final exon
      			previous = this_x+this_width+(graph_width.to_f/gene_length.to_f)*(this_stop-this_start)
      		else
      			previous = this_stop
      		end      		
      	end
      	
      	#draw the final exon
      	graph.add_rectangle({:x => previous, :y => y},graph_width-previous)      	
      	return graph
      	      
      end
      
      def snornas
        return self.slice.genes.select{|g| g.biotype == "snoRNA"}
      end
      
      def softmasked_seq        
        seq = self.seq.upcase        
        noncoding = self.fetch_noncoding        
        noncoding.each do |n|          
          seq.gsub!(/#{n.seq.upcase}/, "#{n.seq.downcase}")          
        end        
        return seq       
      end
      
      def genbank_id
        
        genbank_id = Ensembl::Core::ExternalDb.find_by_db_name('EMBL').id
        xref = self.all_xrefs.select{|x| x.external_db_id == genbank_id}[0]
        return nil if xref.nil?
        return xref.dbprimary_acc
        
      end
      
      def uniprot_id
        db_id = ExternalDb.find_by_db_name("Uniprot/SWISSPROT").external_db_id
        return self.all_xrefs.select{|r| r.external_db_id == db_id}.collect{|r| r.dbprimary_acc}.uniq.compact.shift
      end
      
      def ncrna_id
        if self.biotype == "snoRNA"
          dbname = "RFAM"
        elsif self.biotype == "miRNA"
          dbname = "miRBase"
        end        
        return nil if ExternalDb.find_by_db_name(dbname).nil?
        db_id = ExternalDb.find_by_db_name(dbname).external_db_id
        return self.all_xrefs.select{|r| r.external_db_id == db_id}.collect{|r| r.dbprimary_acc}.uniq.join
      end
      
      def get_externaldb_accs(dbname)
        db_id = ExternalDb.find_by_db_name(dbname).external_db_id
        return self.all_xrefs.select{|r| r.external_db_id == db_id}.collect{|r| r.dbprimary_acc}.uniq
      end
      
      def to_fasta        
        return Bio::FastaFormat.new(Bio::Sequence::NA.new(self.slice.seq).to_fasta("#{self.stable_id}"))      
      end
      
      def get_pfam_features       
        answer = []
        self.transcripts.each do |transcript|
          next if transcript.translation.nil?
          transcript.translation.protein_features.select{|pf| pf.hit_name.match(/^PF[0-9]*/) }.each do |pfam|
            answer.push(pfam.hit_name) unless answer.include?(pfam.hit_name)
          end
        end        
        return answer.sort.uniq        
      end
      
      # = DESCRIPTION
      # This method is used to identify slices that are located
      # within the intron of protein coding genes.
      def is_intronic?
        ncrna = self.slice
        genes = ncrna.genes(true)
        genes.select{|g| g.biotype == "protein_coding"}.each do |gene|
          unless gene.stable_id == self.stable_id
            gene_slice = Slice.fetch_by_gene_stable_id(gene.stable_id)
            if ncrna.within?(gene_slice)
              return true
            end
          end
        end
        return false
      end
      
      def go_terms_with_evidence        
        answer = []
        go_db_id = Ensembl::ExternalDb.find_by_db_name("GO").external_db_id
        self.transcripts.select{|t| t.translation.nil? == false }.each do |transcript|
          transcript.translation.object_xrefs.select{|o| o.xref.external_db_id == go_db_id}.each do |oxref|
            answer.push(["#{oxref.xref.dbprimary_acc}" , "#{oxref.go_xref.linkage_type}"])
          end
        end        
        return answer          
      end
      
      def fetch_hostgene
        return nil unless self.is_intronic?
        ncrna = self.slice
        genes = ncrna.genes(true).select{|g| g.stable_id != self.stable_id}
        genes.each do |gene|
          gene_slice = Slice.fetch_by_gene_stable_id(gene.stable_id)
          if ncrna.within?(gene_slice)
            return gene
          end
        end
      end
      
      def get_longest_transcript        
        answer = nil
        self.transcripts.each do |transcript|
          answer = transcript if answer.nil?
          answer = transcript if transcript.cds_seq.length > answer.cds_seq.length
        end
        return answer       
      end
      
      def fetch_noncoding        
        ranges = []        
        self.transcripts.each do |transcript|
          transcript.introns.each do |intron|
            coords = [ intron.seq_region_start,intron.seq_region_end].sort
            ranges << Range.new(coords.shift,coords.shift)            
          end          
        end        
        answer = []        
        until ranges.empty?
          this_range = ranges.shift
          add = true          
          ranges.each do |range|
            if this_range.eql?(range)   # the same intron is present in the remaining set, ignore the current one
              add = false
            elsif this_range.member?(range.first) and this_range.member?(range.end) # this intron contains another intron - ignore it
              add = false
            elsif this_range.member?(range.first) and this_range.member?(range.end) == false # overlapping upstream, take the overlap only 
              ranges.delete(range)
              this_range = Range.new(range.first,this_range.end)
            elsif this_range.member?(range.first) == false and this_range.member?(range.end) # overlapping downstream, take the overlap only
              this_range = Range.new(this_range.first,range.end)
              ranges.delete(range)
            end            
          end         
          answer << Ensembl::Core::Slice.new(self.seq_region,this_range.first,this_range.end,self.strand) if add == true         
        end       
       return answer        
      end      
    end
    
    class Transcript < DBConnection
      
      def to_fasta      	
      	return Bio::FastaFormat.new(Bio::Sequence::NA.new(self.slice.seq).to_fasta(self.stable_id))
      end
      
      def translation_exons
        answer = []
        self.exons.each do |exon|
          answer.push(exon) if exon.seq_region_end >= self.coding_region_genomic_start and exon.seq_region_start <= self.coding_region_genomic_end
        end
        return answer
      end
      
      def cdna_slices
        translation = self.translation
        answer = []
        self.translation_exons.each do |exon|
          if exon.exon_id == translation.start_exon_id
            slice = Ensembl::Core::Slice.new(exon.seq_region,self.coding_region_genomic_start,exon.seq_region_end,exon.seq_region_strand) if "#{self.strand}" == "1"
            slice = Ensembl::Core::Slice.new(exon.seq_region,exon.seq_region_start,self.coding_region_genomic_end,exon.seq_region_strand) if "#{self.strand}" == "-1"
            answer.push(slice)
          elsif exon.exon_id == translation.end_exon_id
            slice = Ensembl::Core::Slice.new(exon.seq_region,exon.seq_region_start,self.coding_region_genomic_end,exon.strand) if "#{self.strand}" == "1"
            slice = Ensembl::Core::Slice.new(exon.seq_region,self.coding_region_genomic_start,exon.seq_region_end, exon.seq_region_strand) if "#{self.strand}" == "-1"
            answer.push(slice)
          else
            answer.push(exon.slice)
          end
        end
        return answer.uniq
      end
     
      def all_xrefs
        return Ensembl::Core::ObjectXref.find_all_by_ensembl_id_and_ensembl_object_type(self.transcript_id,"Transcript").collect{|ox| ox.xref }
      end
      
      def get_externaldb_accs(dbname)
        db_id = ExternalDb.find_by_db_name(dbname).external_db_id
        return self.all_xrefs.select{|r| r.external_db_id == db_id}.collect{|r| r.dbprimary_acc}.uniq.join
      end
      
      def get_snorna_region(pos)        
        exon = self.exon_for_genomic_position(pos)       
      end
      
      def map_slice(sno_slice,verbose=false)
      	
      	pos = nil     	
      	self.introns.each do |intron|
      		if sno_slice.within?(intron)
						puts "snoRNA within intron: #{intron.previous_exon.stable_id}|#{intron.previous_exon.stop} <- #{intron.start}/#{intron.stop} -> #{intron.next_exon.start}|#{intron.next_exon.stable_id}" if verbose
					if intron.previous_exon.stop > self.coding_region_genomic_end
						puts "exon (partly) non-coding, using genomic_coding_region... (#{self.coding_region_genomic_end} instead of #{intron.previous_exon.stop}), direction is #{self.strand}" if verbose
						pos = self.coding_region_genomic_end
					elsif intron.previous_exon.stop < self.coding_region_genomic_start
						puts "exon (partly) non-coding, using genomic_coding_region... (#{self.coding_region_genomic_start} instead of #{intron.previous_exon.stop}), direction is #{self.strand}" if verbose
						pos = self.coding_region_genomic_start
					else
				 		pos = intron.previous_exon.stop
					end

					end
      	end

      	
      	if pos.nil?       		
      		#if snorna.slice.within?(self.slice)
      		if self.strand == -1
      			if sno_slice.start > self.coding_region_genomic_start
      				pos = self.coding_region_genomic_start
      			else
      				pos = self.coding_region_genomic_end
      			end      				
      		else
      			if sno_slice.stop < self.coding_region_genomic_start
      				pos = self.coding_region_genomic_start
      			else
      				pos = self.coding_region_genomic_end
      			end
      		end      		 
      	end
      	
      	puts "\tUsing this position for the snoRNA: #{pos}" if verbose
      	raise "This snoRNA was not mapped to a neighbouring exon :( #{snorna.stable_id}" if pos.nil?
      	return peptide_position(pos,verbose)
      
      end
      
      def peptide_position(pos,verbose=false)
        
        this_exon = self.exon_for_genomic_position(pos)        
        raise "not within an exon (#{pos})" if self.exon_for_genomic_position(pos).nil?        
        this_pos = 0
        exons = self.exons        
        if self.strand == -1          
          first_exon = self.exon_for_genomic_position(self.coding_region_genomic_end)                    
          start = self.coding_region_genomic_end
          stop = self.coding_region_genomic_start          
          puts "\tGene is reverse, using start: #{start}, stop: #{stop}" if verbose          
          if first_exon.stop > start
            puts "\tFirst exon is #{first_exon.start}<>#{first_exon.stop}, start is #{start} (#{start-first_exon.start})"  if verbose
            this_pos += (start-first_exon.start)
          else
            this_pos += first_exon.length
          end          
          exons[1..-1].each do |exon|
          	next if exon == first_exon
            if exon.stop > first_exon.start
              puts "\tSkipping this exon (#{exon.start},#{exon.stop}) - outside of cDNA scope"  if verbose
            elsif exon == this_exon
              puts "\treached target exon #{exon.start}/#{exon.stop} - pos. was #{pos} (#{exon.stop-pos})"  if verbose
              this_pos += (exon.stop-pos)
              return this_pos
            elsif exon.start < this_exon.stop
            	puts "\tAlready found the correct exon, skipping" if verbose
            else
              puts "\tNot the target exon, adding length (#{exon.length} , now #{this_pos+exon.length})" if verbose
              this_pos += exon.length
            end            
          end          
        else
          
          first_exon = self.exon_for_genomic_position(self.coding_region_genomic_start)          
          start = self.coding_region_genomic_start-1
          stop = self.coding_region_genomic_end-1         
          puts "\tGene is forward, using start: #{start}, stop: #{stop}"  if verbose          
          if start > first_exon.start
            puts "\tFirst exon is #{first_exon.start}, start is #{start} (#{first_exon.stop-start})" if verbose
            this_pos += (first_exon.stop - start)
          else
            this_pos += first_exon.length
          end          
          if first_exon == this_exon
          	puts "\tThe first exon is the the target exon, returning position (#{this_pos})" if verbose
          	return this_pos
          end          
          exons[1..-1].each do |exon|
          	next if exon == first_exon
            puts "\tprocessing exon: #{exon.start}<->#{exon.stop}" if verbose
            if exon.stop < self.coding_region_genomic_start
              puts "\tSkipping this exon (#{exon.start},#{exon.stop}) - outside of cDNA scope"  if verbose
            elsif exon == this_exon
              puts "\treached target exon #{exon.start}/#{exon.stop} - pos. was #{pos} (#{exon.length})"  if verbose
              this_pos += (pos-exon.start)
              return this_pos
            elsif exon.start > this_exon.stop
            	puts "\tAlready found the correct exon, skipping" if verbose
            else  
              puts "\tNot yet the target exon, adding length (#{exon.length})" if verbose
              this_pos += exon.length
            end            
          end              
        end
        return (this_pos)
      end
        
    end
    
    class Translation < DBConnection

      def all_xrefs
        return self.object_xrefs.collect{|ox| ox.xref }
      end

      def get_externaldb_accs(dbname)
        db_id = ExternalDb.find_by_db_name(dbname).external_db_id
        return self.all_xrefs.select{|r| r.external_db_id == db_id}.collect{|r| r.dbprimary_acc}.uniq.join
      end

      def snorna_locations        
        answer = []        
        snornas = self.transcript.gene.snornas        
        self.transcript.introns.each do |intron|          
          snornas.each do |snorna|            
            if snorna.slice.within?(intron)
              #puts "#{intron.previous_exon.stable_id}|#{intron.previous_exon.stop} #{intron.start}/#{intron.stop} #{intron.next_exon.start}|#{intron.next_exon.stable_id}"
              if intron.previous_exon.stop > self.transcript.coding_region_genomic_end and self.transcript.strand == -1
                puts "exon partly non-coding, using genomic_coding_region... (#{self.transcript.coding_region_genomic_end} instead of #{intron.previous_exon.stop}), direction is #{self.transcript.strand}"
                answer << self.transcript.coding_region_genomic_end
              else
                answer << intron.previous_exon.stop
              end
            end            
          end          
        end        
        return answer        
      end
      
      def to_fasta
        return Bio::FastaFormat.new(Bio::Sequence::AA.new(self.seq).to_fasta(self.stable_id))
      end
    end
    
  end
  
  module Compara
    
    class GenomicAlignBlock < DBConnection
      
      # DESCRIPTION
      # Retrieves intragenic DNA for the whole alignment block,
      # Returns a Hash with genomic_align_ids as keys and all
      # slices of non-coding DNA as values in an array
      def fetch_noncoding
        
        answer = {}
        contigs = self.genomic_aligns
        contigs.each do |contig|
          introns = contig.fetch_introns
          answer["#{contig.genomic_align_id}"] = introns 
        end
        
        return answer
        
      end
    end
  
    class GenomicAlign < DBConnection
      
      # = DESCRIPTION
      # Retrieves all non-coding nucleotides located within protein-coding genes 
      # from the underlying DNA fragment
      # NOTE! non-coding DNA is different from introns. Introns are gaps between
      # exons but may contain coding-sequence in case of alternative splicing.
      # This method iterates over all introns and creates a minimal set (nucleotides
      # not covered by exons in any of the transcript!)
      def fetch_noncoding
        
        answer = Array.new
    
        self.get_slice.genes.each do |gene|
          if gene.biotype == "protein_coding"
            gene.fetch_noncoding.each do |nc|
              answer.push(nc)   # a bunch of slice objects ...
            end
          end
        end
        
        return answer
        
      end
    
      def mark_feature(coordinates,strand)
        
        aln_seq = "#{self.aligned_sequence.naseq}" if strand == 1
        aln_seq = "#{self.aligned_sequence.naseq.complement}" if strand == -1
        coordinates.each do |start,stop|
          puts "#{start}/#{stop}"
          aln_seq = aln_seq[0..start-2].downcase + aln_seq[start-1..stop-1].upcase + aln_seq[stop..-1].downcase
        end
        
        return aln_seq
        
      end
        
    end
    
    class Member < DBConnection
      
      def get_longest_peptide_sequence
        
        pep = self.get_longest_peptide_member
        
        return nil if pep.nil?
        
        return Bio::FastaFormat.new(Bio::Sequence::AA.new(pep.sequence.sequence).to_fasta(pep.stable_id))
        
      end
      
      def fetch_ensembl_gene(version=54)
        
        self.genome_db.connect_to_genome(version)
        return Ensembl::Core::Gene.find_by_stable_id("#{self.stable_id}") if self.source_name == "ENSEMBLGENE"
        return Ensembl::Core::Translation.find_by_stable_id("#{self.stable_id}") if self.source_name == "ENSEMBLPEP"
        
      end
      
      def to_fasta
        
        if self.source_name == "ENSEMBLPEP"
          return Bio::FastaFormat.new(Bio::Sequence::AA.new(self.seq).to_fasta(self.stable_id))
        else
          return Bio::FastaFormat.new(Bio::Sequence::NA.new(self.get_gene.slice.seq).to_fasta(self.stable_id))
        end
        
      end
      
      def get_alignment(type="ortholog")
        
        bin = []
        bin << self.to_fasta
        
        self.get_homology_seqs(type).each {|s| bin << s }
        
        aln = Bio::Alignment::OriginalAlignment.new(bin)
        
        factory = Bio::ClustalW.new
        a2 = aln.do_align(factory)
        
        return a2
        
      end
      
      def get_homology_seqs(type=nil)
        
        answer = []
        
        self.fetch_homologues(type).each do |member|
          answer.push(member.to_fasta)
        end
        
        return answer
        
      end
      
      def exonerate_homologs(type)
        
        raise "must have a type" if type.nil?
        target = self.to_fasta
        queries = []
        self.get_homology_seqs(type).each {|s| queries << s }
        
        exonerate = Bio::Exonerate.new("",queries,target)
        exonerate.run
        
      end
        
    end
    
  end
  
  module PanCompara
    
    class Member
      
      def get_longest_peptide_sequence
        
        pep = self.get_longest_peptide_member
        
        return nil if pep.nil?
        
        return Bio::FastaFormat.new(Bio::Sequence::AA.new(pep.sequence.sequence).to_fasta(pep.stable_id))
        
      end
      
      def get_ensembl_gene(version=54)
        self.genome_db.connect_to_genome(version)
        return Ensembl::Core::Gene.find_by_stable_id(self.stable_id)
      end  
    end
    
  end
    
end
