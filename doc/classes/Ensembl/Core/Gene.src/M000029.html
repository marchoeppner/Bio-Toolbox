<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
<head>
  <title>fetch_noncoding (Ensembl::Core::Gene)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <link rel="stylesheet" href="../../../.././rdoc-style.css" type="text/css" media="screen" />
</head>
<body class="standalone-code">
  <pre><span class="ruby-comment cmt"># File lib/extensions.rb, line 147</span>
      <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">fetch_noncoding</span>
        
        <span class="ruby-identifier">raise</span> <span class="ruby-node">&quot;#{self.stable_id} is not a protein coding gene!&quot;</span> <span class="ruby-keyword kw">unless</span>  <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">biotype</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;protein_coding&quot;</span>
        
        <span class="ruby-identifier">answer</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>
        <span class="ruby-identifier">exons</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>
        <span class="ruby-identifier">exon_hash</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span> <span class="ruby-comment cmt"># A hash of unique keys and the start/stop of introns - iteratively extended/contracted to cover true non-coding regions of the gene</span>
        
        <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">transcripts</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">t</span><span class="ruby-operator">|</span>
          <span class="ruby-identifier">t</span>.<span class="ruby-identifier">exons</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span>
            <span class="ruby-identifier">exons</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">e</span>) <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">exons</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">e</span>)
          <span class="ruby-keyword kw">end</span> 
        <span class="ruby-keyword kw">end</span>
          
        <span class="ruby-identifier">exons</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">exon</span><span class="ruby-operator">|</span>
          
          <span class="ruby-identifier">add</span> = <span class="ruby-keyword kw">true</span>

          <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">exon</span>.<span class="ruby-identifier">start</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">exon</span>.<span class="ruby-identifier">stop</span>
            <span class="ruby-identifier">exon_start</span> = <span class="ruby-identifier">exon</span>.<span class="ruby-identifier">stop</span>
            <span class="ruby-identifier">exon_stop</span> = <span class="ruby-identifier">exon</span>.<span class="ruby-identifier">start</span>
          <span class="ruby-keyword kw">else</span>
            <span class="ruby-identifier">exon_start</span> = <span class="ruby-identifier">exon</span>.<span class="ruby-identifier">start</span>
            <span class="ruby-identifier">exon_stop</span> = <span class="ruby-identifier">exon</span>.<span class="ruby-identifier">stop</span>
          <span class="ruby-keyword kw">end</span>

          <span class="ruby-identifier">exon_hash</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">k</span>,<span class="ruby-identifier">v</span><span class="ruby-operator">|</span>                           <span class="ruby-comment cmt"># exon IDs are used as key, but without particular meaning to it - just to have unique keys for hash updates (else one could use array inserts..)</span>

            <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">exon_start</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">v</span>[<span class="ruby-value">1</span>] <span class="ruby-keyword kw">and</span> <span class="ruby-identifier">exon_stop</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">v</span>[<span class="ruby-value">1</span>]      <span class="ruby-comment cmt"># exon partially overlaps an existing one, re-define coding boundaries downstream</span>
              <span class="ruby-identifier">exon_hash</span>[<span class="ruby-node">&quot;#{k}&quot;</span>] = [ <span class="ruby-identifier">exon_hash</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-node">&quot;#{k}&quot;</span>)[<span class="ruby-value">0</span>], <span class="ruby-identifier">exon_stop</span> ]
              <span class="ruby-identifier">add</span> = <span class="ruby-keyword kw">false</span>
            <span class="ruby-keyword kw">elsif</span> <span class="ruby-identifier">exon_start</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">v</span>[<span class="ruby-value">0</span>] <span class="ruby-keyword kw">and</span> <span class="ruby-identifier">exon_stop</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-identifier">v</span>[<span class="ruby-value">0</span>]  <span class="ruby-comment cmt"># exon partially overlaps an existing one, re-define coding boundaries upstream</span>
              <span class="ruby-identifier">exon_hash</span>[<span class="ruby-node">&quot;#{k}&quot;</span>] = [ <span class="ruby-identifier">exon_start</span>, <span class="ruby-identifier">exon_hash</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-node">&quot;#{k}&quot;</span>)[<span class="ruby-value">1</span>] ]
              <span class="ruby-identifier">add</span> = <span class="ruby-keyword kw">false</span>
            <span class="ruby-keyword kw">elsif</span> <span class="ruby-identifier">exon_start</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-identifier">v</span>[<span class="ruby-value">0</span>] <span class="ruby-keyword kw">and</span> <span class="ruby-identifier">exon_stop</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">v</span>[<span class="ruby-value">1</span>]  <span class="ruby-comment cmt"># is identical or included in another exon and thus ignored</span>
              <span class="ruby-identifier">add</span> = <span class="ruby-keyword kw">false</span>
            <span class="ruby-keyword kw">end</span>
          
          <span class="ruby-keyword kw">end</span>

          <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">add</span> <span class="ruby-operator">==</span> <span class="ruby-keyword kw">false</span>                               <span class="ruby-comment cmt"># if the exon is unique and does not (partially) overlap another yet processed exon</span>
            <span class="ruby-identifier">exon_hash</span>[<span class="ruby-identifier">exon</span>.<span class="ruby-identifier">stable_id</span>] = [ <span class="ruby-identifier">exon_start</span>, <span class="ruby-identifier">exon_stop</span> ]
          <span class="ruby-keyword kw">end</span>
        <span class="ruby-keyword kw">end</span>

        <span class="ruby-identifier">sorter</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>                                  <span class="ruby-comment cmt"># Some array to store the coordinates (array of arrays) in</span>
        <span class="ruby-identifier">exon_hash</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ex</span>,<span class="ruby-identifier">coordinates</span><span class="ruby-operator">|</span>
          <span class="ruby-identifier">sorter</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">coordinates</span>)
        <span class="ruby-keyword kw">end</span>
        <span class="ruby-identifier">sorter</span>.<span class="ruby-identifier">sort!</span>                                        <span class="ruby-comment cmt"># sort the exon coordinates (required for intron position reconstruction)</span>

        <span class="ruby-keyword kw">until</span> <span class="ruby-identifier">sorter</span>.<span class="ruby-identifier">nitems</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>                            <span class="ruby-comment cmt"># iterate over all exons and infer intron coordinates (stop of upstream exon, start of downstream exon +/-1)</span>

          <span class="ruby-identifier">intron_start</span> = <span class="ruby-identifier">sorter</span>.<span class="ruby-identifier">shift</span>[<span class="ruby-value">1</span>]<span class="ruby-operator">+</span><span class="ruby-value">1</span>
          <span class="ruby-identifier">intron_stop</span> = <span class="ruby-identifier">sorter</span>.<span class="ruby-identifier">first</span>[<span class="ruby-value">0</span>]<span class="ruby-operator">-</span><span class="ruby-value">1</span>

          <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">intron_start</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">intron_stop</span>                <span class="ruby-comment cmt"># an intron that has &gt; zero length...</span>

            <span class="ruby-identifier">coord</span> = [ <span class="ruby-identifier">intron_start</span>, <span class="ruby-identifier">intron_stop</span> ]
            <span class="ruby-identifier">coord</span>.<span class="ruby-identifier">sort!</span>

            <span class="ruby-identifier">intron</span> = <span class="ruby-constant">Ensembl</span><span class="ruby-operator">::</span><span class="ruby-constant">Core</span><span class="ruby-operator">::</span><span class="ruby-constant">Slice</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">seq_region</span>,<span class="ruby-identifier">coord</span>[<span class="ruby-value">0</span>],<span class="ruby-identifier">coord</span>[<span class="ruby-value">1</span>],<span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">strand</span>)
            
            <span class="ruby-comment cmt"># A stretch of non-coding DNA extrapolated from exon gaps</span>
            <span class="ruby-comment cmt"># may still contain other coding features (ncRNAs)!</span>
            <span class="ruby-comment cmt"># Will be removed in this step...</span>
            <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">intron</span>.<span class="ruby-identifier">genes</span>.<span class="ruby-identifier">empty?</span>
              <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">intron</span>)
            <span class="ruby-keyword kw">else</span>
              <span class="ruby-identifier">ranges</span> = []
              <span class="ruby-identifier">intron</span>.<span class="ruby-identifier">genes</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">gene</span><span class="ruby-operator">|</span>
                <span class="ruby-identifier">ranges</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">gene</span>.<span class="ruby-identifier">slice</span>.<span class="ruby-identifier">start</span>.<span class="ruby-identifier">to_i</span><span class="ruby-operator">..</span><span class="ruby-identifier">gene</span>.<span class="ruby-identifier">slice</span>.<span class="ruby-identifier">stop</span>.<span class="ruby-identifier">to_i</span>)
              <span class="ruby-keyword kw">end</span>  
              <span class="ruby-identifier">introns</span> = <span class="ruby-identifier">intron</span>.<span class="ruby-identifier">excise</span>(<span class="ruby-identifier">ranges</span>)  
              <span class="ruby-identifier">introns</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">i</span>)}
            <span class="ruby-keyword kw">end</span>
            
          <span class="ruby-keyword kw">end</span>
        <span class="ruby-keyword kw">end</span>

        <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">answer</span>

      <span class="ruby-keyword kw">end</span></pre>
</body>
</html>